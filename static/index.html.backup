<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syberè€æ - ä½ çš„AIåæ‹çˆ±è„‘é—ºèœœ/æƒ…æ„Ÿæ­å­Agent</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="chat-container">
        <!-- é¡¶éƒ¨åŒºåŸŸ - ç²¾ç®€è®¾è®¡ -->
        <div class="chat-header">
            <div class="header-left">
                <div class="chat-title">
                    Syberè€æ ğŸ’œ
                    <span id="personaDisplay" class="persona-status">ğŸ’¬ æ­£å¸¸èŠå¤©</span>
                </div>
                <div class="chat-subtitle">AIåæ‹çˆ±è„‘é—ºèœœ - ä½ çš„åæ§½/æ¯’èˆŒ/å…«å¦/æƒ…æ„Ÿæ­å­</div>
            </div>
            
            <div class="header-right">
                <!-- æ‹çˆ±è„‘æŒ‡æ•° - æ‰©å±•ç‰ˆæœ¬ -->
                <div class="love-brain-indicator love-brain-hidden" id="loveBrainIndicator">
                    <div class="love-brain-compact">
                        <div class="meter-header">
                            <span>æ‹çˆ±è„‘æŒ‡æ•°ï¼š<span id="meterValue">--</span></span>
                            <span class="meter-level" id="meterLevel">æœªæ£€æµ‹</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-fill" id="meterFill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>



                <!-- è®°å¿†çŠ¶æ€æŒ‡ç¤ºå™¨ -->
                <div class="memory-indicator" id="memoryIndicator" title="ç‚¹å‡»æŸ¥çœ‹è®°å¿†è¯¦æƒ…">
                    <div class="memory-compact">
                        <span class="memory-icon">ğŸ§ </span>
                        <span class="memory-text">è®°å¿†: <span id="memoryRounds">0</span>è½®</span>
                        <span class="memory-usage" id="memoryUsage">0%</span>
                    </div>
                </div>
                
                <button class="new-session-button" id="newSessionButton">ğŸ”„ æ–°ä¼šè¯</button>
            </div>
        </div>
        
        <!-- èŠå¤©æ¶ˆæ¯åŒºåŸŸ -->
        <div class="chat-messages" id="chatMessages">
            <div class="message ai">
                <div class="message-avatar">æ‹½</div>
                <div class="message-content">
                    <div class="typewriter" id="welcomeMessage"></div>
                </div>
            </div>
        </div>
        
        <!-- åº•éƒ¨è¾“å…¥åŒºåŸŸ -->
        <div class="chat-input-container">
            <div class="persona-selector">
                <div class="persona-modes">
                    <span class="persona-label">æ¨¡å¼:</span>
                    <div class="persona-option active" data-button-type="æ­£å¸¸èŠå¤©">ğŸ’¬ æ­£å¸¸èŠå¤©</div>
                    <div class="persona-option" data-button-type="ğŸŒŠå¯¹æˆ˜æµ·ç‹">ğŸŒŠ å¯¹æˆ˜æµ·ç‹</div>
                    <div class="persona-option" data-button-type="ğŸµåèŒ¶è‰ºå¤§å¸ˆ">ğŸµ åèŒ¶è‰ºå¤§å¸ˆ</div>
                    <div class="persona-option" data-button-type="ğŸŒˆå†³æˆ˜é€šè®¯å½•ä¹‹å·…">ğŸŒˆ å†³æˆ˜é€šè®¯å½•ä¹‹å·…</div>
                    <div class="persona-option" data-button-type="ğŸ’ƒå§¬åœˆæ“‚å°èµ›">ğŸ’ƒ å§¬åœˆæ“‚å°èµ›</div>
                </div>
                
                <!-- æµ·ç‹æ¨¡å¼å¾—åˆ†æŒ‡ç¤ºå™¨ - åªåœ¨æµ·ç‹æ¨¡å¼æ—¶æ˜¾ç¤ºï¼Œå±…å³æ˜¾ç¤º -->
                <div class="seaking-score-inline seaking-score-hidden" id="seakingScoreInline">
                    <span class="seaking-score-icon">ğŸ†</span>
                    <span class="seaking-score-text">å¾—åˆ†: <span id="seakingScoreValue">0</span></span>
                    <div class="seaking-score-progress">
                        <div class="seaking-score-fill" id="seakingScoreFill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="chat-input-wrapper">
                <textarea 
                    id="chatInput" 
                    class="chat-input" 
                    placeholder="æ¥ï¼Œè·Ÿè€æè¯´è¯´ä½ çš„å›°æ‰°å§..."
                    rows="1"
                ></textarea>
                <button id="sendButton" class="send-button">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22,2 15,22 11,13 2,9 22,2"></polygon>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let currentButtonType = 'æ­£å¸¸èŠå¤©';
        let currentSeakingScore = 0;

        let isTyping = false;
        let conversationHistory = [];
        let currentSeakingPersona = null; // å­˜å‚¨å½“å‰æµ·ç‹å¯¹æˆ˜çš„äººè®¾ä¿¡æ¯
        let hasTriggeredFirstRound = false; // é˜²æ­¢é‡å¤è§¦å‘ç¬¬ä¸€è½®å¯¹è¯

        // DOM å…ƒç´ 
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const personaOptions = document.querySelectorAll('.persona-option');
        const personaDisplay = document.getElementById('personaDisplay');
        const newSessionButton = document.getElementById('newSessionButton');
        const welcomeMessage = document.getElementById('welcomeMessage');
        
        // æ‹çˆ±è„‘æŒ‡æ•°ç›¸å…³å…ƒç´ 
        const loveBrainIndicator = document.getElementById('loveBrainIndicator');
        const meterFill = document.getElementById('meterFill');
        const meterLevel = document.getElementById('meterLevel');
        const meterValue = document.getElementById('meterValue');

        // æµ·ç‹å¯¹æˆ˜å¾—åˆ†ç›¸å…³å…ƒç´ 
        const seakingScoreInline = document.getElementById('seakingScoreInline');
        const seakingScoreValue = document.getElementById('seakingScoreValue');
        const seakingScoreFill = document.getElementById('seakingScoreFill');

        // è®°å¿†çŠ¶æ€ç›¸å…³å…ƒç´ 
        const memoryIndicator = document.getElementById('memoryIndicator');
        const memoryRounds = document.getElementById('memoryRounds');
        const memoryUsage = document.getElementById('memoryUsage');

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            typeWelcomeMessage();
            chatInput.focus();
            autoResizeTextarea();
            // å»¶è¿ŸåŠ è½½è®°å¿†çŠ¶æ€ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åˆå§‹åŒ–
            setTimeout(() => {
                console.log('ğŸ é¡µé¢åˆå§‹åŒ–ï¼šå¼€å§‹åŠ è½½è®°å¿†çŠ¶æ€');
                loadMemoryStats();
            }, 500);
        });

        // æ¬¢è¿æ¶ˆæ¯æ‰“å­—æœºæ•ˆæœ
        function typeWelcomeMessage() {
            const messages = [
                "ğŸ˜ˆ è€¶æ–¯è«æ‹‰ï¼é›†ç¾å¥½ä¹…ä¸è§å•Šï¼â€”â€”å§æ˜¯ä½ çš„èµ›åšé“å­è€æğŸ’œï¼æœ‰å•¥æƒ…æ„Ÿå›°æ‰°å°½ç®¡æ¥åæ§½ï¼ä¹Ÿå¯ä»¥è¯•è¯•ğŸ®å¯¹æˆ˜æµ·ç‹æ¨¡å¼ï¼Œå­¦å­¦å’‹åæ‹çˆ±å¥—è·¯ï¼"
            ];
            
            let messageIndex = 0;
            let charIndex = 0;
            
            function typeChar() {
                if (messageIndex < messages.length) {
                    if (charIndex < messages[messageIndex].length) {
                        const char = messages[messageIndex].charAt(charIndex);
                        welcomeMessage.textContent += char;
                        charIndex++;
                        setTimeout(typeChar, 30);
                    } else {
                        // å½“å‰æ¶ˆæ¯å®Œæˆï¼Œç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ¶ˆæ¯
                        messageIndex++;
                        charIndex = 0;
                        if (messageIndex < messages.length) {
                            welcomeMessage.textContent += '\n';
                            setTimeout(typeChar, 800);
                        }
                        // æ‰€æœ‰æ¶ˆæ¯å®Œæˆï¼Œæ— éœ€ç‰¹æ®Šå¤„ç†
                    }
                }
            }
            
            typeChar();
        }

        // è‡ªåŠ¨è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦
        function autoResizeTextarea() {
            chatInput.addEventListener('input', function() {
                // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
                const currentScrollTop = chatMessages.scrollTop;
                
                // ä¸´æ—¶è®¾ç½®ä¸ºautoæ¥è®¡ç®—æ‰€éœ€é«˜åº¦
                const currentHeight = this.style.height;
                this.style.height = 'auto';
                const newHeight = Math.min(this.scrollHeight, 120);
                
                // å¹³æ»‘è¿‡æ¸¡åˆ°æ–°é«˜åº¦
                this.style.height = newHeight + 'px';
                
                // æ¢å¤æ»šåŠ¨ä½ç½®ï¼Œé¿å…è·³åŠ¨
                chatMessages.scrollTop = currentScrollTop;
            });
        }

        // è·å–æ¨¡å¼æ˜¾ç¤ºæ–‡æœ¬ï¼ˆå¸¦emojiï¼‰
        function getPersonaDisplayText(text, buttonType) {
            // ç›´æ¥è¿”å›æŒ‰é’®æ–‡æœ¬ï¼Œå› ä¸ºæŒ‰é’®æ–‡æœ¬å·²ç»åŒ…å«äº†å¯¹åº”çš„icon
            return text;
        }

        // æ¨¡å¼åˆ‡æ¢
        personaOptions.forEach(option => {
            option.addEventListener('click', async function() {
                personaOptions.forEach(opt => opt.classList.remove('active'));
                this.classList.add('active');
                currentButtonType = this.dataset.buttonType;
                personaDisplay.textContent = getPersonaDisplayText(this.textContent, currentButtonType);
                
                console.log('æ¨¡å¼åˆ‡æ¢:', currentButtonType);
                
                // é‡ç½®æµ·ç‹å¯¹æˆ˜çŠ¶æ€
                if (currentButtonType !== 'æ­£å¸¸èŠå¤©') {
                    // åªæœ‰åœ¨åˆ‡æ¢ä¸åŒæ¨¡å¼æˆ–æ²¡æœ‰å½“å‰äººè®¾æ—¶æ‰é‡ç½®çŠ¶æ€
                    const shouldReset = !currentSeakingPersona || currentSeakingPersona.button_type !== currentButtonType;
                    
                    if (shouldReset) {
                        currentSeakingScore = 0;
                        hasTriggeredFirstRound = false; // é‡ç½®ç¬¬ä¸€è½®è§¦å‘æ ‡è®°
                        
                        // ä»æœ¬åœ°JSONæ–‡ä»¶è·å–äººè®¾
                        try {
                            const personasResponse = await fetch(`/static/personas.json?v=${Date.now()}`);
                            if (personasResponse.ok) {
                                const personasData = await personasResponse.json();
                                console.log('[DEBUG] è·å–åˆ°çš„personasæ•°æ®:', Object.keys(personasData));
                                console.log('[DEBUG] å½“å‰æŒ‰é’®ç±»å‹:', currentButtonType);
                                const config = personasData[currentButtonType];
                                console.log('[DEBUG] æ‰¾åˆ°çš„é…ç½®:', config);
                                if (config && config.personas) {
                                    // éšæœºé€‰æ‹©ä¸€ä¸ªäººè®¾
                                    const randomPersona = config.personas[Math.floor(Math.random() * config.personas.length)];
                                    currentSeakingPersona = {
                                        button_type: currentButtonType,
                                        persona: randomPersona.name,
                                        gender: randomPersona.gender,
                                        user_gender: randomPersona.user_gender,
                                        challenge_type: randomPersona.challenge_type,
                                        first_greeting: randomPersona.first_greeting,
                                        description: randomPersona.description,
                                        style: randomPersona.style,
                                        weakness: randomPersona.weakness
                                    };
                                    console.log('è·å–æ–°äººè®¾:', currentSeakingPersona);
                                    
                                    // æ˜¾ç¤ºäººè®¾è¯´æ˜
                                    addSystemMessage(`å·²åˆ‡æ¢è¿›å…¥${this.textContent}æ¨¡å¼ï¼Œç›®æ ‡æ˜¯å›å¤å¾—åˆ†è¾¾100ï¼æœ¬æ¬¡æŒ‘æˆ˜æµ·ç‹ï¼š${randomPersona.name}`);
                                    
                                    // è‡ªåŠ¨è§¦å‘ç¬¬ä¸€è½®å¯¹è¯ï¼Œè·å–æŒ‘æˆ˜ç›®æ ‡å’Œæµ·ç‹å¼€åœºç™½
                                    setTimeout(async () => {
                                        await triggerFirstSeakingRound();
                                    }, 500);
                                } else {
                                    addSystemMessage(`å·²åˆ‡æ¢åˆ° ${this.textContent} æ¨¡å¼ï¼Œå‡†å¤‡å¼€å§‹æµ·ç‹å¯¹æˆ˜ï¼`);
                                }
                            } else {
                                addSystemMessage(`å·²åˆ‡æ¢åˆ° ${this.textContent} æ¨¡å¼ï¼Œå‡†å¤‡å¼€å§‹æµ·ç‹å¯¹æˆ˜ï¼`);
                            }
                        } catch (error) {
                            console.error('è·å–äººè®¾å¤±è´¥:', error);
                            addSystemMessage(`å·²åˆ‡æ¢åˆ° ${this.textContent} æ¨¡å¼ï¼Œå‡†å¤‡å¼€å§‹æµ·ç‹å¯¹æˆ˜ï¼`);
                        }
                    } else {
                        // å¦‚æœä¸éœ€è¦é‡ç½®ï¼Œåªæ˜¾ç¤ºå½“å‰æ¨¡å¼ä¿¡æ¯
                        addSystemMessage(`ç»§ç»­${this.textContent}æ¨¡å¼ï¼Œå½“å‰æµ·ç‹ï¼š${currentSeakingPersona.persona}`);
                    }
                    
                    // æ˜¾ç¤ºæµ·ç‹å¾—åˆ†æŒ‡ç¤ºå™¨
                    updateSeakingScore(currentSeakingScore);
                } else {
                    // åˆ‡æ¢åˆ°æ­£å¸¸èŠå¤©æ¨¡å¼æ—¶ï¼Œé‡ç½®æ‰€æœ‰æµ·ç‹ç›¸å…³çŠ¶æ€
                    currentSeakingScore = 0;
                    hasTriggeredFirstRound = false; // é‡ç½®ç¬¬ä¸€è½®è§¦å‘æ ‡è®°
                    // éšè—æµ·ç‹å¾—åˆ†æŒ‡ç¤ºå™¨
                    resetSeakingScore();
                    // æ¸…é™¤å¯¹è¯å†å²ï¼Œé¿å…æ˜¾ç¤ºæµ·ç‹å¯¹æˆ˜å†…å®¹
                    conversationHistory = [];
                    
                    // é‡ç½®æœåŠ¡å™¨ç«¯è®°å¿†ï¼Œé¿å…æµ·ç‹å¯¹æˆ˜å†å²å½±å“æ­£å¸¸èŠå¤©
                    try {
                        const resetResponse = await fetch('/reset', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            }
                        });
                        if (resetResponse.ok) {
                            console.log('æœåŠ¡å™¨è®°å¿†é‡ç½®æˆåŠŸ');
                            // æ¸…é™¤å‰ç«¯å¯¹è¯å†å²
                            chatMessages.innerHTML = '';
                            
                            // åœ¨æ¸…ç©ºåæ·»åŠ åˆ‡æ¢åˆ°æ­£å¸¸èŠå¤©çš„ç³»ç»Ÿæ¶ˆæ¯
                            addSystemMessage('å·²è¿›å…¥ğŸ’¬æ­£å¸¸èŠå¤©æ¨¡å¼ï¼Œç»§ç»­å’Œè€æå” å—‘å§ï¼');
                            
                            // æ·»åŠ æ‹½å§çš„æ¬¢è¿æ¶ˆæ¯
                            setTimeout(() => {
                                addMessage('ğŸš¬ç©å®Œå›æ¥å•¦ï¼Ÿç»§ç»­æƒ³èŠç‚¹å•¥å‘€é“å­', 'ai');
                            }, 500);
                        }
                    } catch (error) {
                        console.error('é‡ç½®è®°å¿†å¤±è´¥:', error);
                        // å³ä½¿é‡ç½®å¤±è´¥ä¹Ÿæ˜¾ç¤ºåˆ‡æ¢æ¶ˆæ¯
                        addSystemMessage('å·²è¿›å…¥ğŸ’¬æ­£å¸¸èŠå¤©æ¨¡å¼ï¼Œç»§ç»­å’Œè€æå” å—‘å§ï¼');
                        setTimeout(() => {
                            addMessage('ğŸš¬ç©å®Œå›æ¥å•¦ï¼Ÿç»§ç»­æƒ³èŠç‚¹å•¥å‘€é“å­', 'ai');
                        }, 500);
                    }
                }
            });
        });

        // å‘é€æ¶ˆæ¯
        sendButton.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // æ–°ä¼šè¯
        newSessionButton.addEventListener('click', async function() {
            try {
                // è°ƒç”¨åç«¯é‡ç½®ä¼šè¯
                const response = await fetch('/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // é‡ç½®å‰ç«¯çŠ¶æ€
                conversationHistory = [];
                currentSeakingScore = 0;
                currentSeakingPersona = null; // æ¸…é™¤äººè®¾ä¿¡æ¯
                hasTriggeredFirstRound = false; // é‡ç½®ç¬¬ä¸€è½®è§¦å‘æ ‡è®°
                chatMessages.innerHTML = `
                    <div class="message ai">
                        <div class="message-avatar">æ‹½</div>
                        <div class="message-content">å¼€å§‹æ–°çš„å¯¹è¯å§ï¼æˆ‘ä¼šç»§ç»­å¸®ä½ ä¿æŒç†æ™ºæ¸…é†’ ğŸ˜‰</div>
                    </div>
                `;
                resetLoveBrainMeter();
                resetSeakingScore();
                resetMemoryStats();
                
                // æ›´æ–°è®°å¿†çŠ¶æ€
                if (data.memory_stats) {
                    updateMemoryStats(data.memory_stats);
                }
                
                scrollToBottom();
                
            } catch (error) {
                console.error('é‡ç½®ä¼šè¯å¤±è´¥:', error);
                // é™çº§å¤„ç†ï¼šä»…å‰ç«¯é‡ç½®
                conversationHistory = [];
                chatMessages.innerHTML = `
                    <div class="message ai">
                        <div class="message-avatar">æ‹½</div>
                        <div class="message-content">å¼€å§‹æ–°çš„å¯¹è¯å§ï¼æˆ‘ä¼šç»§ç»­å¸®ä½ ä¿æŒç†æ™ºæ¸…é†’ ğŸ˜‰</div>
                    </div>
                `;
                resetLoveBrainMeter();
                resetSeakingScore();
                resetMemoryStats();
                scrollToBottom();
                
                // æ˜¾ç¤ºé”™è¯¯æç¤º
                addMessage('ä¼šè¯é‡ç½®æˆåŠŸï¼Œä½†æœåŠ¡å™¨çŠ¶æ€å¯èƒ½æœªå®Œå…¨é‡ç½®', 'ai');
            }
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message || isTyping) return;

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            addMessage(message, 'user');
            chatInput.value = '';
            // å¹³æ»‘é‡ç½®åˆ°åˆå§‹é«˜åº¦
            chatInput.style.height = '60px';

            // æ˜¾ç¤ºæ‰“å­—æŒ‡ç¤ºå™¨
            showTypingIndicator();

            try {
                let response;
                
                if (currentButtonType !== 'æ­£å¸¸èŠå¤©' && currentSeakingPersona) {
                    // æµ·ç‹å¯¹æˆ˜æ¨¡å¼ - ç›´æ¥è°ƒç”¨seaking chain
                    const seakingRequestBody = {
                        message: message,
                        button_type: currentButtonType,
                        seaking_score: currentSeakingScore,
                        persona: currentSeakingPersona.persona,
                        gender: currentSeakingPersona.gender,
                        user_gender: currentSeakingPersona.user_gender,
                        challenge_type: currentSeakingPersona.challenge_type,
                        description: currentSeakingPersona.description,
                        style: currentSeakingPersona.style,
                        weakness: currentSeakingPersona.weakness
                    };
                    
                    console.log('æµ·ç‹å¯¹æˆ˜è¯·æ±‚å‚æ•°:', seakingRequestBody);
                    
                    response = await fetch('/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(seakingRequestBody)
                    });
                } else {
                    // æ­£å¸¸èŠå¤©æ¨¡å¼
                    const normalRequestBody = {
                        message: message,
                        button_type: currentButtonType,
                        seaking_score: currentSeakingScore,
                        history: conversationHistory
                    };
                    
                    console.log('æ­£å¸¸èŠå¤©è¯·æ±‚å‚æ•°:', normalRequestBody);
                    
                    response = await fetch('/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(normalRequestBody)
                    });
                }

                const data = await response.json();
                
                if (response.ok) {
                    hideTypingIndicator();
                    
                    // æ›´æ–°æ‹çˆ±è„‘æŒ‡æ•°
                    if (data.love_brain_index !== undefined) {
                        updateLoveBrainMeter(data.love_brain_index, data.love_brain_level);
                    }
                    
                    // æ›´æ–°è®°å¿†çŠ¶æ€
                    if (data.memory_stats) {
                        updateMemoryStats(data.memory_stats);
                    } else {
                        // å¦‚æœå“åº”ä¸­æ²¡æœ‰memory_statsï¼Œä¸»åŠ¨è·å–æœ€æ–°çŠ¶æ€
                        await loadMemoryStats();
                    }
                    
                    // æ›´æ–°æµ·ç‹å¯¹æˆ˜çŠ¶æ€
                    if (data.seaking_mode && isSeakingMode(currentButtonType)) {
                        const newScore = data.seaking_mode.current_score || 0;
                        console.log('[DEBUG] æµ·ç‹å¾—åˆ†æ›´æ–°:', {
                            oldScore: currentSeakingScore,
                            newScore: newScore,
                            seakingMode: data.seaking_mode
                        });
                        currentSeakingScore = newScore;
                        
                        // æ›´æ–°å¾—åˆ†æ˜¾ç¤ºï¼ˆåªåœ¨æµ·ç‹æ¨¡å¼ä¸‹ï¼‰
                        updateSeakingScore(currentSeakingScore);
                        
                        // æ£€æŸ¥æ˜¯å¦é€šå…³
                        if (data.seaking_mode.is_victory) {
                            addSystemMessage('ğŸ‰ æ­å–œé€šå…³ï¼ä½ å·²ç»æˆåŠŸåº”å¯¹äº†æµ·ç‹çš„å¥—è·¯ï¼');
                            // è‡ªåŠ¨åˆ‡æ¢å›æ­£å¸¸èŠå¤©æ¨¡å¼
                            setTimeout(() => {
                                const normalChatOption = document.querySelector('[data-button-type="æ­£å¸¸èŠå¤©"]');
                                if (normalChatOption) {
                                    normalChatOption.click();
                                }
                            }, 2000);
                        }
                    }
                    
                    // æ·»åŠ AIå›å¤
                    console.log('å½“å‰æ¨¡å¼:', currentButtonType);
                    console.log('å“åº”å†…å®¹:', data.response);
                    
                    if (currentButtonType !== 'æ­£å¸¸èŠå¤©') {
                        // æµ·ç‹å¯¹æˆ˜æ¨¡å¼ - è§£æä¸‰æ®µå¼è¾“å‡º
                        console.log('ä½¿ç”¨æµ·ç‹å¯¹æˆ˜æ¨¡å¼è§£æ');
                        await parseSeakingResponse(data.response);
                    } else {
                        // æ™®é€šèŠå¤©æ¨¡å¼
                        console.log('ä½¿ç”¨æ™®é€šèŠå¤©æ¨¡å¼æ˜¾ç¤º');
                        await addMessageWithTypewriter(data.response, 'ai');
                    }
                    
                    // æ›´æ–°å¯¹è¯å†å²
                    conversationHistory.push(
                        { role: 'user', content: message },
                        { role: 'assistant', content: data.response }
                    );
                } else {
                    hideTypingIndicator();
                    const errorMessage = data.detail || data.error || `HTTP ${response.status}: ${response.statusText}`;
                    addMessage(`æŠ±æ­‰ï¼Œå‡ºç°äº†é”™è¯¯ï¼š${errorMessage}`, 'ai');
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('èŠå¤©è¯·æ±‚å¤±è´¥:', error);
                addMessage('ç½‘ç»œè¿æ¥å‡ºç°é—®é¢˜ï¼Œè¯·ç¨åé‡è¯•', 'ai');
            }
        }

        function addMessage(content, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = sender === 'user' ? 'ä½ ' : 
                                sender === 'seaking' ? 'ç‹' : 'æ‹½';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            scrollToBottom();
            return messageDiv;
        }

        async function addMessageWithTypewriter(content, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = sender === 'user' ? 'ä½ ' : 
                                sender === 'seaking' ? 'ç‹' : 'æ‹½';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            const typewriter = document.createElement('div');
            typewriter.className = 'typewriter';
            messageContent.appendChild(typewriter);
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            // æ‰“å­—æœºæ•ˆæœ
            let i = 0;
            
            function typeChar() {
                if (i < content.length) {
                    typewriter.textContent += content.charAt(i);
                    i++;
                    // å‡å°‘æ»šåŠ¨é¢‘ç‡ï¼Œåªåœ¨æ¢è¡Œæ—¶æ»šåŠ¨
                    if (content.charAt(i-1) === '\n') {
                        scrollToBottom();
                    }
                    setTimeout(typeChar, 30);
                } else {
                    // æ‰“å­—å®Œæˆåæœ€ç»ˆæ»šåŠ¨
                    scrollToBottom();
                }
            }
            
            typeChar();
        }

        // è§£ææµ·ç‹å¯¹æˆ˜çš„ä¸‰æ®µå¼è¾“å‡º
        async function parseSeakingResponse(content) {
            console.log('è§£ææµ·ç‹å¯¹æˆ˜è¾“å‡º:', content);
            
            // è§£ææŒ‘æˆ˜ç›®æ ‡ï¼ˆé¦–æ¬¡å¯¹è¯ï¼‰
            const challengeMatch = content.match(/ã€æŒ‘æˆ˜ç›®æ ‡ã€‘([^ã€]*)/);
            if (challengeMatch) {
                const challengeText = challengeMatch[1].trim();
                console.log('è§£æåˆ°æŒ‘æˆ˜ç›®æ ‡:', challengeText);
                if (challengeText) {
                    addSystemMessage(`ğŸ¯ æŒ‘æˆ˜ç›®æ ‡: ${challengeText}`);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // è§£ææµ·ç‹å›å¤
            const seakingMatch = content.match(/ã€æµ·ç‹ã€‘([^ã€]*)/);
            if (seakingMatch) {
                let seakingText = seakingMatch[1].trim();
                // æ¸…ç†æ ¼å¼ - å»æ‰äººè®¾åç§°å‰ç¼€
                seakingText = seakingText.replace(/^[ï¼š""\s]+/, '');
                seakingText = seakingText.replace(/[""]\s*$/, '');
                seakingText = seakingText.replace(/\s*ï¼ˆ[^ï¼‰]*ï¼‰.*$/, '');
                
                // å»æ‰äººè®¾åç§°å‰ç¼€ï¼ˆå¦‚"INFP-æ²»æ„ˆæ–‡é’å‹æµ·ç‹ï¼š"ï¼‰
                if (seakingText.includes('ï¼š')) {
                    const colonIndex = seakingText.indexOf('ï¼š');
                    seakingText = seakingText.substring(colonIndex + 1).trim();
                }
                
                seakingText = seakingText.replace(/\s+/g, ' ').trim();
                
                console.log('è§£æåˆ°æµ·ç‹å›å¤:', seakingText);
                
                if (seakingText) {
                    await addSeakingMessage(seakingText);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } else {
                console.log('æœªæ‰¾åˆ°æµ·ç‹å›å¤æ ¼å¼');
            }
            
            // è§£æå¯é€‰å›åº”å»ºè®®
            const suggestionMatch = content.match(/ã€ä½ ã€‘å¯é€‰å›åº”å»ºè®®ï¼š([^ã€]*)/);
            if (suggestionMatch) {
                const suggestionText = suggestionMatch[1].trim();
                console.log('è§£æåˆ°å›åº”å»ºè®®:', suggestionText);
                if (suggestionText) {
                    addSystemMessage(`ğŸ’¡ å¯é€‰å›åº”å»ºè®®: ${suggestionText}`);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // è§£ææ‹½å§æ—ç™½
            const commentMatch = content.match(/ã€æ‹½å§æ—ç™½ã€‘([^ã€]*)/);
            if (commentMatch) {
                const commentText = commentMatch[1].trim();
                console.log('è§£æåˆ°æ‹½å§æ—ç™½:', commentText);
                if (commentText) {
                    addSystemMessage(commentText);
                }
            } else {
                console.log('æœªæ‰¾åˆ°æ‹½å§æ—ç™½æ ¼å¼');
            }
        }

        async function addSeakingMessage(content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message seaking';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = 'ç‹';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            const typewriter = document.createElement('div');
            typewriter.className = 'typewriter';
            messageContent.appendChild(typewriter);
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            
            // æ‰“å­—æœºæ•ˆæœ
            let i = 0;
            
            function typeSeakingChar() {
                if (i < content.length) {
                    typewriter.textContent += content.charAt(i);
                    i++;
                    if (content.charAt(i-1) === '\n') {
                        scrollToBottom();
                    }
                    setTimeout(typeSeakingChar, 30);
                } else {
                    scrollToBottom();
                }
            }
            
            typeSeakingChar();
        }

        function addSystemMessage(content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;
            
            // ç³»ç»Ÿæ¶ˆæ¯ä¸éœ€è¦å¤´åƒï¼Œç›´æ¥æ·»åŠ å†…å®¹
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            scrollToBottom();
        }

        function showTypingIndicator() {
            isTyping = true;
            sendButton.disabled = true;
            
            const typingDiv = document.createElement('div');
            // æ ¹æ®å½“å‰æ¨¡å¼è®¾ç½®ä¸åŒçš„ç±»åå’Œå¤´åƒæ ·å¼
            if (currentButtonType !== 'æ­£å¸¸èŠå¤©') {
                typingDiv.className = 'message seaking';
            } else {
                typingDiv.className = 'message ai';
            }
            typingDiv.id = 'typing-indicator';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = currentButtonType !== 'æ­£å¸¸èŠå¤©' ? 'ç‹' : 'æ‹½';
            
            const indicatorContent = document.createElement('div');
            indicatorContent.className = 'typing-indicator';
            
            const dots = document.createElement('div');
            dots.className = 'typing-dots';
            
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'typing-dot';
                dots.appendChild(dot);
            }
            
            indicatorContent.appendChild(dots);
            typingDiv.appendChild(avatar);
            typingDiv.appendChild(indicatorContent);
            chatMessages.appendChild(typingDiv);
            
            scrollToBottom();
        }

        function hideTypingIndicator() {
            isTyping = false;
            sendButton.disabled = false;
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function scrollToBottom() {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        // æ‹çˆ±è„‘æŒ‡æ•°æ›´æ–°å‡½æ•°
        function updateLoveBrainMeter(index, level) {
            loveBrainIndicator.classList.remove('love-brain-hidden');
            
            // æ›´æ–°æ•°å€¼
            meterValue.textContent = index;
            
            // è½¬æ¢ç­‰çº§æ˜¾ç¤ºæ ¼å¼
            let displayLevel = level || 'æœªçŸ¥';
            if (level === 'è½»') displayLevel = 'è½»åº¦';
            else if (level === 'ä¸­') displayLevel = 'ä¸­åº¦';
            else if (level === 'é‡') displayLevel = 'é‡åº¦';
            else if (level === 'å±é™©') displayLevel = 'å±é™©';
            
            meterLevel.textContent = displayLevel;
            
            // æ›´æ–°è¿›åº¦æ¡
            meterFill.style.width = `${index}%`;
            
            // æ›´æ–°ç­‰çº§æ ·å¼ - ä½¿ç”¨åŸå§‹çš„levelä½œä¸ºCSSç±»å
            meterLevel.className = 'meter-level';
            if (level) {
                meterLevel.classList.add(level);
            }
            
            // æ·»åŠ åŠ¨ç”»æ•ˆæœ
            loveBrainIndicator.style.animation = 'pulse 0.5s ease-in-out';
            setTimeout(() => {
                loveBrainIndicator.style.animation = '';
            }, 500);
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºæµ·ç‹æ¨¡å¼
        function isSeakingMode(buttonType) {
            return buttonType !== 'æ­£å¸¸èŠå¤©';
        }

        // æ›´æ–°æµ·ç‹å¯¹æˆ˜å¾—åˆ†
        function updateSeakingScore(score) {
            console.log('[DEBUG] updateSeakingScore è¢«è°ƒç”¨');
            console.log('[DEBUG] currentButtonType:', currentButtonType);
            console.log('[DEBUG] isSeakingModeç»“æœ:', isSeakingMode(currentButtonType));
            console.log('[DEBUG] score:', score);
            
            if (isSeakingMode(currentButtonType)) {
                console.log('[DEBUG] æ˜¾ç¤ºå¾—åˆ†æŒ‡ç¤ºå™¨');
                seakingScoreInline.classList.remove('seaking-score-hidden');
                // æ¸…é™¤å†…è”éšè—æ ·å¼ï¼Œè®©CSSç±»ç”Ÿæ•ˆ
                seakingScoreInline.style.display = '';
                seakingScoreValue.textContent = score;
                seakingScoreFill.style.width = `${score}%`;
                
                // æ·»åŠ åŠ¨ç”»æ•ˆæœ
                seakingScoreInline.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    seakingScoreInline.style.animation = '';
                }, 500);
            } else {
                console.log('[DEBUG] éšè—å¾—åˆ†æŒ‡ç¤ºå™¨');
                seakingScoreInline.classList.add('seaking-score-hidden');
                // å¼ºåˆ¶éšè—ï¼šåŒæ—¶ä½¿ç”¨CSSç±»å’Œå†…è”æ ·å¼
                seakingScoreInline.style.display = 'none';
            }
        }

        // é‡ç½®æµ·ç‹å¯¹æˆ˜å¾—åˆ†
        function resetSeakingScore() {
            console.log('[DEBUG] resetSeakingScore è¢«è°ƒç”¨');
            seakingScoreInline.classList.add('seaking-score-hidden');
            // å¼ºåˆ¶éšè—ï¼šåŒæ—¶ä½¿ç”¨CSSç±»å’Œå†…è”æ ·å¼
            seakingScoreInline.style.display = 'none';
            seakingScoreFill.style.width = '0%';
            seakingScoreValue.textContent = '0';
            console.log('[DEBUG] å¾—åˆ†æŒ‡ç¤ºå™¨å·²éšè—ï¼ˆåŒé‡ä¿é™©ï¼‰');
        }

        // é‡ç½®æ‹çˆ±è„‘æŒ‡æ•°
        function resetLoveBrainMeter() {
            loveBrainIndicator.classList.add('love-brain-hidden');
            meterFill.style.width = '0%';
            meterLevel.textContent = 'æœªæ£€æµ‹';
            meterLevel.className = 'meter-level';
            meterValue.textContent = '--';
        }

        // åŠ è½½è®°å¿†çŠ¶æ€
        async function loadMemoryStats() {
            try {
                const response = await fetch('/memory/stats');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                updateMemoryStats(data);
            } catch (error) {
                console.error('âŒ åŠ è½½è®°å¿†çŠ¶æ€å¤±è´¥:', error);
                // è®¾ç½®é»˜è®¤å€¼
                resetMemoryStats();
            }
        }

        // æ›´æ–°è®°å¿†çŠ¶æ€
        function updateMemoryStats(stats) {
            if (!stats) {
                console.warn('âš ï¸ è®°å¿†çŠ¶æ€æ•°æ®ä¸ºç©º');
                return;
            }
            
            // æ›´æ–°è½®æ•°
            const roundCount = stats.conversation_count || 0;
            memoryRounds.textContent = roundCount;
            
            // æ›´æ–°ä½¿ç”¨ç‡
            const usageRatio = stats.memory_usage_ratio || 0;
            const usagePercent = Math.round(usageRatio * 100);
            memoryUsage.textContent = `${usagePercent}%`;
            
            // æ›´æ–°æ ·å¼
            memoryUsage.className = 'memory-usage';
            if (usagePercent >= 80) {
                memoryUsage.classList.add('high');
            } else if (usagePercent >= 60) {
                memoryUsage.classList.add('medium');
            } else {
                memoryUsage.classList.add('low');
            }
            
            // æ›´æ–°æç¤ºä¿¡æ¯
            let tooltipText = `å¯¹è¯è½®æ•°: ${stats.conversation_count}\n`;
            tooltipText += `Tokenä½¿ç”¨: ${stats.estimated_tokens}/${stats.max_tokens}\n`;
            tooltipText += `ä½¿ç”¨ç‡: ${usagePercent}%`;
            
            if (stats.user_patterns && Object.keys(stats.user_patterns).length > 0) {
                tooltipText += '\nè¡Œä¸ºæ¨¡å¼: ' + Object.entries(stats.user_patterns)
                    .map(([pattern, count]) => `${pattern}(${count})`)
                    .join(', ');
            }
            
            memoryIndicator.title = tooltipText;
        }

        // è®°å¿†è¯¦æƒ…ç‚¹å‡»äº‹ä»¶
        function showMemoryModal(data) {
            // ç§»é™¤å·²å­˜åœ¨çš„modal
            const oldModal = document.getElementById('memoryModal');
            if (oldModal) oldModal.remove();

            const modal = document.createElement('div');
            modal.id = 'memoryModal';
            modal.style.position = 'fixed';
            modal.style.left = '0';
            modal.style.top = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.background = 'rgba(0,0,0,0.6)';
            modal.style.zIndex = '9999';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.backdropFilter = 'blur(4px)';

            const content = document.createElement('div');
            content.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            content.style.padding = '40px';
            content.style.borderRadius = '20px';
            content.style.maxWidth = '1200px';
            content.style.width = '95vw';
            content.style.maxHeight = '90vh';
            content.style.overflow = 'auto';
            content.style.position = 'relative';
            content.style.boxShadow = '0 20px 40px rgba(0,0,0,0.3)';
            content.style.border = '2px solid rgba(255,255,255,0.1)';
            content.style.color = 'white';
            content.style.fontFamily = 'Inter, sans-serif';

            // å…³é—­æŒ‰é’®
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = 'âœ•';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '16px';
            closeBtn.style.right = '20px';
            closeBtn.style.fontSize = '1.5rem';
            closeBtn.style.background = 'rgba(255,255,255,0.2)';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '50%';
            closeBtn.style.width = '36px';
            closeBtn.style.height = '36px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.color = 'white';
            closeBtn.style.display = 'flex';
            closeBtn.style.alignItems = 'center';
            closeBtn.style.justifyContent = 'center';
            closeBtn.style.transition = 'all 0.3s ease';
            closeBtn.onmouseover = () => {
                closeBtn.style.background = 'rgba(255,255,255,0.3)';
                closeBtn.style.transform = 'scale(1.1)';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = 'rgba(255,255,255,0.2)';
                closeBtn.style.transform = 'scale(1)';
            };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);

            // æ ‡é¢˜
            const title = document.createElement('h2');
            title.textContent = 'ğŸ§  æ™ºèƒ½è®°å¿†è¯¦æƒ…';
            title.style.marginTop = '0';
            title.style.marginBottom = '32px';
            title.style.fontSize = '2rem';
            title.style.fontWeight = '600';
            title.style.textAlign = 'center';
            title.style.textShadow = '0 2px 4px rgba(0,0,0,0.3)';
            content.appendChild(title);

            // åˆ›å»ºç½‘æ ¼å®¹å™¨
            const gridContainer = document.createElement('div');
            gridContainer.style.display = 'grid';
            gridContainer.style.gridTemplateColumns = '1fr 1fr';
            gridContainer.style.gap = '24px';
            gridContainer.style.marginBottom = '20px';
            content.appendChild(gridContainer);

            // ç»Ÿè®¡ä¿¡æ¯å¡ç‰‡
            const stats = data.stats || {};
            const statsCard = document.createElement('div');
            statsCard.style.background = 'rgba(255,255,255,0.1)';
            statsCard.style.padding = '20px';
            statsCard.style.borderRadius = '12px';
            statsCard.style.backdropFilter = 'blur(10px)';
            statsCard.style.border = '1px solid rgba(255,255,255,0.2)';
            
            statsCard.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 16px;">
                    <span style="font-size: 1.5rem; margin-right: 8px;">ğŸ“Š</span>
                    <strong style="font-size: 1.1rem;">ç»Ÿè®¡ä¿¡æ¯</strong>
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 0.9rem;">
                    <div>å¯¹è¯è½®æ•°: <span style="color: #ffd700; font-weight: 600;">${stats.conversation_count || 0}</span></div>
                    <div>Tokenä½¿ç”¨: <span style="color: #ffd700; font-weight: 600;">${stats.estimated_tokens || 0}/${stats.max_tokens || 0}</span></div>
                    <div>ä½¿ç”¨ç‡: <span style="color: #ffd700; font-weight: 600;">${Math.round((stats.memory_usage_ratio || 0) * 100)}%</span></div>
                    <div>è¡Œä¸ºæ¨¡å¼: <span style="color: #ffd700; font-weight: 600;">${stats.pattern_count || 0}ç§</span></div>
                </div>
            `;
            gridContainer.appendChild(statsCard);

            // ç”¨æˆ·ç”»åƒå¡ç‰‡
            if (data.user_profile && data.user_profile.summary) {
                const profileCard = document.createElement('div');
                profileCard.style.background = 'rgba(255,255,255,0.1)';
                profileCard.style.padding = '20px';
                profileCard.style.borderRadius = '12px';
                profileCard.style.backdropFilter = 'blur(10px)';
                profileCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                let profileContent = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">ğŸ‘¤</span>
                        <strong style="font-size: 1.1rem;">ç”¨æˆ·ç”»åƒåˆ†æ</strong>
                    </div>
                    <div style="font-size: 0.9rem; line-height: 1.6; margin-bottom: 12px;">
                        ${data.user_profile.summary}
                    </div>
                `;
                
                if (data.user_profile.personality_traits && data.user_profile.personality_traits.length > 0) {
                    profileContent += `
                        <div style="margin-top: 12px;">
                            <strong style="color: #ffd700;">ä¸ªæ€§ç‰¹å¾:</strong>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                                ${data.user_profile.personality_traits.map(trait => 
                                    `<span style="background: rgba(255,215,0,0.2); padding: 6px 12px; border-radius: 16px; font-size: 0.85rem; border: 1px solid rgba(255,215,0,0.3);">${trait}</span>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                }
                
                profileCard.innerHTML = profileContent;
                gridContainer.appendChild(profileCard);
            } else {
                // å¦‚æœç”¨æˆ·ç”»åƒä¸ºç©ºï¼Œåˆ›å»ºä¸€ä¸ªå ä½å¡ç‰‡
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">ğŸ‘¤</span>ç”¨æˆ·ç”»åƒæ•°æ®ä¸è¶³</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // ä¸Šä¸‹æ–‡æ‘˜è¦
            if (data.context_summary && data.context_summary !== "æš‚æ— è®°å¿†ä¸Šä¸‹æ–‡") {
                const ctxCard = document.createElement('div');
                ctxCard.style.background = 'rgba(255,255,255,0.1)';
                ctxCard.style.padding = '20px';
                ctxCard.style.borderRadius = '12px';
                ctxCard.style.backdropFilter = 'blur(10px)';
                ctxCard.style.border = '1px solid rgba(255,255,255,0.2)';
                ctxCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">ğŸ“‹</span>
                        <strong style="font-size: 1.1rem;">ä¸Šä¸‹æ–‡æ‘˜è¦</strong>
                    </div>
                    <div style="font-size: 0.9rem; line-height: 1.6;">${data.context_summary}</div>
                `;
                gridContainer.appendChild(ctxCard);
            } else {
                // å¦‚æœä¸Šä¸‹æ–‡æ‘˜è¦ä¸ºç©ºï¼Œåˆ›å»ºä¸€ä¸ªå ä½å¡ç‰‡
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">ğŸ“‹</span>æš‚æ— ä¸Šä¸‹æ–‡æ‘˜è¦</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // è¡Œä¸ºæ¨¡å¼åˆ†æ
            if (stats.user_patterns && Object.keys(stats.user_patterns).length > 0) {
                const patternCard = document.createElement('div');
                patternCard.style.background = 'rgba(255,255,255,0.1)';
                patternCard.style.padding = '20px';
                patternCard.style.borderRadius = '12px';
                patternCard.style.backdropFilter = 'blur(10px)';
                patternCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                const patternItems = Object.entries(stats.user_patterns)
                    .sort((a, b) => b[1] - a[1])
                    .map(([pattern, count]) => {
                        const intensity = count >= 3 ? 'ğŸ”´' : count >= 2 ? 'ğŸŸ¡' : 'ğŸŸ¢';
                        return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <span style="font-size: 0.95rem;">${intensity} ${pattern}</span>
                            <span style="color: #ffd700; font-weight: 600; font-size: 0.95rem;">${count}æ¬¡</span>
                        </div>`;
                    }).join('');
                
                patternCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">ğŸ¯</span>
                        <strong style="font-size: 1.1rem;">è¡Œä¸ºæ¨¡å¼åˆ†æ</strong>
                    </div>
                    <div style="font-size: 0.9rem;">
                        ${patternItems}
                    </div>
                `;
                gridContainer.appendChild(patternCard);
            } else {
                // å¦‚æœè¡Œä¸ºæ¨¡å¼ä¸ºç©ºï¼Œåˆ›å»ºä¸€ä¸ªå ä½å¡ç‰‡
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">ğŸ¯</span>æš‚æ— è¡Œä¸ºæ¨¡å¼æ•°æ®</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // å…³é”®æ´å¯Ÿ
            if (data.long_term_details && data.long_term_details.key_insights && data.long_term_details.key_insights.length > 0) {
                const insightCard = document.createElement('div');
                insightCard.style.background = 'rgba(255,255,255,0.1)';
                insightCard.style.padding = '20px';
                insightCard.style.borderRadius = '12px';
                insightCard.style.backdropFilter = 'blur(10px)';
                insightCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                const insightItems = data.long_term_details.key_insights
                    .slice(-3) // åªæ˜¾ç¤ºæœ€è¿‘3æ¡
                    .map(insight => `<div style="padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 0.9rem; line-height: 1.5;">ğŸ’¡ ${insight}</div>`)
                    .join('');
                
                insightCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">ğŸ’¡</span>
                        <strong style="font-size: 1.1rem;">å…³é”®æ´å¯Ÿ</strong>
                    </div>
                    <div>
                        ${insightItems}
                    </div>
                `;
                gridContainer.appendChild(insightCard);
            }

            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // æ·»åŠ åŠ¨ç”»æ•ˆæœ
            content.style.opacity = '0';
            content.style.transform = 'scale(0.8)';
            setTimeout(() => {
                content.style.transition = 'all 0.3s ease';
                content.style.opacity = '1';
                content.style.transform = 'scale(1)';
            }, 10);
        }

        memoryIndicator.addEventListener('click', async function() {
            try {
                const response = await fetch('/memory/summary');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                showMemoryModal(data);
            } catch (error) {
                console.error('è·å–è®°å¿†è¯¦æƒ…å¤±è´¥:', error);
                alert('è·å–è®°å¿†è¯¦æƒ…å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        });

        // é‡ç½®è®°å¿†çŠ¶æ€
        function resetMemoryStats() {
            memoryRounds.textContent = '0';
            memoryUsage.textContent = '0%';
            memoryUsage.className = 'memory-usage low';
            memoryIndicator.title = 'è®°å¿†å·²é‡ç½®';
        }

        // é¡µé¢åˆå§‹åŒ–ï¼šç¡®ä¿å¾—åˆ†æŒ‡ç¤ºå™¨åœ¨æ­£å¸¸èŠå¤©æ¨¡å¼ä¸‹è¢«éšè—
        function initializeUI() {
            console.log('[DEBUG] åˆå§‹åŒ–UIçŠ¶æ€');
            console.log('[DEBUG] currentButtonType:', currentButtonType);
            console.log('[DEBUG] isSeakingModeç»“æœ:', isSeakingMode(currentButtonType));
            
            // ç¡®ä¿å¾—åˆ†æŒ‡ç¤ºå™¨æ ¹æ®å½“å‰æ¨¡å¼æ­£ç¡®æ˜¾ç¤º/éšè—
            if (currentButtonType === 'æ­£å¸¸èŠå¤©') {
                console.log('[DEBUG] æ­£å¸¸èŠå¤©æ¨¡å¼ï¼Œéšè—å¾—åˆ†æŒ‡ç¤ºå™¨');
                resetSeakingScore();
                
                // è°ƒè¯•ï¼šæ£€æŸ¥å…ƒç´ çš„å®é™…æ ·å¼
                setTimeout(() => {
                    const computedStyle = window.getComputedStyle(seakingScoreInline);
                    console.log('[DEBUG] å…ƒç´ CSSç±»:', seakingScoreInline.className);
                    console.log('[DEBUG] å†…è”æ ·å¼display:', seakingScoreInline.style.display);
                    console.log('[DEBUG] è®¡ç®—åçš„display:', computedStyle.display);
                    console.log('[DEBUG] å…ƒç´ æ˜¯å¦å¯è§:', seakingScoreInline.offsetWidth > 0 && seakingScoreInline.offsetHeight > 0);
                }, 100);
            } else {
                console.log('[DEBUG] æµ·ç‹æ¨¡å¼ï¼Œæ˜¾ç¤ºå¾—åˆ†æŒ‡ç¤ºå™¨');
                updateSeakingScore(currentSeakingScore);
            }
        }

        // è‡ªåŠ¨è§¦å‘ç¬¬ä¸€è½®æµ·ç‹å¯¹æˆ˜
        async function triggerFirstSeakingRound() {
            if (currentButtonType === 'æ­£å¸¸èŠå¤©' || !currentSeakingPersona || hasTriggeredFirstRound) {
                return;
            }
            
            // æ ‡è®°å·²è§¦å‘ï¼Œé˜²æ­¢é‡å¤
            hasTriggeredFirstRound = true;
            
            try {
                console.log('[DEBUG] è§¦å‘ç¬¬ä¸€è½®æµ·ç‹å¯¹æˆ˜');
                
                // ç›´æ¥æ˜¾ç¤ºæŒ‘æˆ˜ç›®æ ‡å’Œæµ·ç‹å¼€åœºç™½ï¼Œä¸å‘é€è¯·æ±‚åˆ°åç«¯
                if (currentSeakingPersona.challenge_goal) {
                    addSystemMessage(currentSeakingPersona.challenge_goal);
                }
                
                if (currentSeakingPersona.first_greeting) {
                    // æµ·ç‹å¼€åœºç™½åº”è¯¥æ˜¾ç¤ºä¸ºæµ·ç‹å¤´åƒï¼ˆçº¢è‰²ï¼‰
                    addMessage(currentSeakingPersona.first_greeting, 'seaking');
                }
                
                console.log('[DEBUG] ç¬¬ä¸€è½®æµ·ç‹å¯¹æˆ˜å†…å®¹å·²æ˜¾ç¤º');
            } catch (error) {
                console.error('ç¬¬ä¸€è½®æµ·ç‹å¯¹æˆ˜è§¦å‘å¤±è´¥:', error);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–UIçŠ¶æ€
        initializeUI();
    </script>
</body>
</html>
