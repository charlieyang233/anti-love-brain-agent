<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI老李 - 你的反恋爱脑赛博闺蜜搭子 Agent</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="chat-container">
        <!-- 顶部区域 - 精简设计 -->
        <div class="chat-header">
            <div class="header-left">
                <div class="chat-title">
                    AI老李 💜
                    <span id="personaDisplay" class="persona-status">💬 正常聊天</span>
                </div>
                <div class="chat-subtitle">你的赛博反恋爱脑闺蜜搭子 - 毒舌/八卦/吐槽/恋爱顾问</div>
            </div>
            
            <div class="header-right">
                <!-- 恋爱脑指数 - 扩展版本 -->
                <div class="love-brain-indicator love-brain-hidden" id="loveBrainIndicator">
                    <div class="love-brain-compact">
                        <div class="meter-header">
                            <span>恋爱脑指数：<span id="meterValue">--</span></span>
                            <span class="meter-level" id="meterLevel">未检测</span>
                        </div>
                        <div class="meter-bar">
                            <div class="meter-fill" id="meterFill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <!-- 记忆状态指示器 -->
                <div class="memory-indicator" id="memoryIndicator" title="点击查看记忆详情">
                    <div class="memory-compact">
                        <span class="memory-icon">🧠</span>
                        <span class="memory-text">记忆: <span id="memoryRounds">0</span>轮</span>
                        <span class="memory-usage" id="memoryUsage">0%</span>
                    </div>
                </div>
                
                <button class="new-session-button" id="newSessionButton">🔄 新会话</button>
            </div>
        </div>
        
        <!-- 聊天消息区域 -->
        <div class="chat-messages" id="chatMessages">
            <div class="message ai">
                <div class="message-avatar">拽</div>
                <div class="message-content">
                    <div class="typewriter" id="welcomeMessage"></div>
                </div>
            </div>
        </div>
        
        <!-- 底部输入区域 -->
        <div class="chat-input-container">
            <div class="persona-selector">
                <span class="persona-label">模式:</span>
                <div class="persona-option active" data-persona="">正常聊天</div>
                <div class="persona-option" data-persona="高冷学霸型">海王模拟-学霸</div>
                <div class="persona-option" data-persona="温柔暖男型">海王模拟-暖男</div>
                <div class="persona-option" data-persona="霸道总裁型">海王模拟-总裁</div>
            </div>
            <div class="chat-input-wrapper">
                <textarea 
                    id="chatInput" 
                    class="chat-input" 
                    placeholder="跟拽姐说说你的困扰吧..."
                    rows="1"
                ></textarea>
                <button id="sendButton" class="send-button">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22,2 15,22 11,13 2,9 22,2"></polygon>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let currentPersona = '';
        let isTyping = false;
        let conversationHistory = [];

        // DOM 元素
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const personaOptions = document.querySelectorAll('.persona-option');
        const personaDisplay = document.getElementById('personaDisplay');
        const newSessionButton = document.getElementById('newSessionButton');
        const welcomeMessage = document.getElementById('welcomeMessage');
        
        // 恋爱脑指数相关元素
        const loveBrainIndicator = document.getElementById('loveBrainIndicator');
        const meterFill = document.getElementById('meterFill');
        const meterLevel = document.getElementById('meterLevel');
        const meterValue = document.getElementById('meterValue');

        // 记忆状态相关元素
        const memoryIndicator = document.getElementById('memoryIndicator');
        const memoryRounds = document.getElementById('memoryRounds');
        const memoryUsage = document.getElementById('memoryUsage');

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            typeWelcomeMessage();
            chatInput.focus();
            autoResizeTextarea();
            // 延迟加载记忆状态，确保页面完全初始化
            setTimeout(() => {
                console.log('🏁 页面初始化：开始加载记忆状态');
                loadMemoryStats();
            }, 500);
        });

        // 欢迎消息打字机效果
        function typeWelcomeMessage() {
            const messages = [
                "😈 耶斯——莫拉！集美好久不见啊！\n\n姐是你的毒舌铁子'老李'💜！有啥情感困扰尽管来吐槽！你要想练练反PUA，也可以试试海王模拟模式，姐跟你演演~"
            ];
            
            let messageIndex = 0;
            let charIndex = 0;
            
            function typeChar() {
                if (messageIndex < messages.length) {
                    if (charIndex < messages[messageIndex].length) {
                        const char = messages[messageIndex].charAt(charIndex);
                        welcomeMessage.textContent += char;
                        charIndex++;
                        setTimeout(typeChar, 30);
                    } else {
                        // 当前消息完成，移动到下一个消息
                        messageIndex++;
                        charIndex = 0;
                        if (messageIndex < messages.length) {
                            welcomeMessage.textContent += '\n';
                            setTimeout(typeChar, 800);
                        }
                        // 所有消息完成，无需特殊处理
                    }
                }
            }
            
            typeChar();
        }

        // 自动调整文本框高度
        function autoResizeTextarea() {
            chatInput.addEventListener('input', function() {
                // 保存当前滚动位置
                const currentScrollTop = chatMessages.scrollTop;
                
                // 临时设置为auto来计算所需高度
                const currentHeight = this.style.height;
                this.style.height = 'auto';
                const newHeight = Math.min(this.scrollHeight, 120);
                
                // 平滑过渡到新高度
                this.style.height = newHeight + 'px';
                
                // 恢复滚动位置，避免跳动
                chatMessages.scrollTop = currentScrollTop;
            });
        }

        // 获取模式显示文本（带emoji）
        function getPersonaDisplayText(text, persona) {
            if (!persona) {
                return '💬 ' + text;
            } else {
                return '😈 ' + text;
            }
        }

        // 人格切换
        personaOptions.forEach(option => {
            option.addEventListener('click', function() {
                personaOptions.forEach(opt => opt.classList.remove('active'));
                this.classList.add('active');
                currentPersona = this.dataset.persona;
                personaDisplay.textContent = getPersonaDisplayText(this.textContent, currentPersona);
                
                // 海王模式特殊处理
                if (currentPersona) {
                    addSystemMessage(`已切换到 ${this.textContent} 模式`);
                } else {
                    addSystemMessage('已切换到正常聊天模式');
                }
            });
        });

        // 发送消息
        sendButton.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // 新会话
        newSessionButton.addEventListener('click', async function() {
            try {
                // 调用后端重置会话
                const response = await fetch('/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // 重置前端状态
                conversationHistory = [];
                chatMessages.innerHTML = `
                    <div class="message ai">
                        <div class="message-avatar">拽</div>
                        <div class="message-content">开始新的对话吧！我会继续帮你保持理智清醒 😉</div>
                    </div>
                `;
                resetLoveBrainMeter();
                resetMemoryStats();
                
                // 更新记忆状态
                if (data.memory_stats) {
                    updateMemoryStats(data.memory_stats);
                }
                
                scrollToBottom();
                
            } catch (error) {
                console.error('重置会话失败:', error);
                // 降级处理：仅前端重置
                conversationHistory = [];
                chatMessages.innerHTML = `
                    <div class="message ai">
                        <div class="message-avatar">拽</div>
                        <div class="message-content">开始新的对话吧！我会继续帮你保持理智清醒 😉</div>
                    </div>
                `;
                resetLoveBrainMeter();
                resetMemoryStats();
                scrollToBottom();
                
                // 显示错误提示
                addMessage('会话重置成功，但服务器状态可能未完全重置', 'ai');
            }
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message || isTyping) return;

            // 添加用户消息
            addMessage(message, 'user');
            chatInput.value = '';
            // 平滑重置到初始高度
            chatInput.style.height = '60px';

            // 显示打字指示器
            showTypingIndicator();

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        persona: currentPersona,
                        history: conversationHistory
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    hideTypingIndicator();
                    
                    // 更新恋爱脑指数
                    if (data.love_brain_index !== undefined) {
                        updateLoveBrainMeter(data.love_brain_index, data.love_brain_level);
                    }
                    
                    // 更新记忆状态
                    if (data.memory_stats) {
                        updateMemoryStats(data.memory_stats);
                    } else {
                        // 如果响应中没有memory_stats，主动获取最新状态
                        await loadMemoryStats();
                    }
                    
                    // 添加AI回复
                    if (currentPersona && currentPersona.trim() !== '') {
                        // 海王模拟模式 - 解析三段式输出
                        await parseSeakingResponse(data.response);
                    } else {
                        // 普通聊天模式
                        await addMessageWithTypewriter(data.response, 'ai');
                    }
                    
                    // 更新对话历史
                    conversationHistory.push(
                        { role: 'user', content: message },
                        { role: 'assistant', content: data.response }
                    );
                } else {
                    hideTypingIndicator();
                    const errorMessage = data.detail || data.error || `HTTP ${response.status}: ${response.statusText}`;
                    addMessage(`抱歉，出现了错误：${errorMessage}`, 'ai');
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('聊天请求失败:', error);
                addMessage('网络连接出现问题，请稍后重试', 'ai');
            }
        }

        function addMessage(content, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = sender === 'user' ? '你' : 
                                sender === 'seaking' ? '王' : '拽';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            scrollToBottom();
            return messageDiv;
        }

        async function addMessageWithTypewriter(content, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = sender === 'user' ? '你' : 
                                sender === 'seaking' ? '王' : '拽';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            const typewriter = document.createElement('div');
            typewriter.className = 'typewriter';
            messageContent.appendChild(typewriter);
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            // 打字机效果
            let i = 0;
            
            function typeChar() {
                if (i < content.length) {
                    typewriter.textContent += content.charAt(i);
                    i++;
                    // 减少滚动频率，只在换行时滚动
                    if (content.charAt(i-1) === '\n') {
                        scrollToBottom();
                    }
                    setTimeout(typeChar, 30);
                } else {
                    // 打字完成后最终滚动
                    scrollToBottom();
                }
            }
            
            typeChar();
        }

        // 解析海王模拟的三段式输出
        async function parseSeakingResponse(content) {
            console.log('解析海王模拟器输出:', content);
            
            // 解析海王回复
            const seakingMatch = content.match(/【海王】([^【]*)/);
            if (seakingMatch) {
                let seakingText = seakingMatch[1].trim();
                // 清理格式
                seakingText = seakingText.replace(/^[：""\s]+/, '');
                seakingText = seakingText.replace(/[""]\s*$/, '');
                seakingText = seakingText.replace(/\s*（[^）]*）.*$/, '');
                seakingText = seakingText.replace(/\s+/g, ' ').trim();
                
                console.log('解析到海王回复:', seakingText);
                
                if (seakingText) {
                    await addSeakingMessage(seakingText);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } else {
                console.log('未找到海王回复格式');
            }
            
            // 解析拽姐旁白
            const commentMatch = content.match(/【拽姐旁白】([^【]*)/);
            if (commentMatch) {
                const commentText = commentMatch[1].trim();
                console.log('解析到拽姐旁白:', commentText);
                if (commentText) {
                    addSystemMessage(commentText);
                }
            } else {
                console.log('未找到拽姐旁白格式');
            }
        }

        async function addSeakingMessage(content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message seaking';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = '王';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            const typewriter = document.createElement('div');
            typewriter.className = 'typewriter';
            messageContent.appendChild(typewriter);
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            
            // 打字机效果
            let i = 0;
            
            function typeSeakingChar() {
                if (i < content.length) {
                    typewriter.textContent += content.charAt(i);
                    i++;
                    if (content.charAt(i-1) === '\n') {
                        scrollToBottom();
                    }
                    setTimeout(typeSeakingChar, 30);
                } else {
                    scrollToBottom();
                }
            }
            
            typeSeakingChar();
        }

        function addSystemMessage(content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = '系';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
            
            scrollToBottom();
        }

        function showTypingIndicator() {
            isTyping = true;
            sendButton.disabled = true;
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message ai';
            typingDiv.id = 'typing-indicator';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = currentPersona ? '王' : '拽';
            
            const indicatorContent = document.createElement('div');
            indicatorContent.className = 'typing-indicator';
            
            const dots = document.createElement('div');
            dots.className = 'typing-dots';
            
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'typing-dot';
                dots.appendChild(dot);
            }
            
            indicatorContent.appendChild(dots);
            typingDiv.appendChild(avatar);
            typingDiv.appendChild(indicatorContent);
            chatMessages.appendChild(typingDiv);
            
            scrollToBottom();
        }

        function hideTypingIndicator() {
            isTyping = false;
            sendButton.disabled = false;
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function scrollToBottom() {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        // 恋爱脑指数更新函数
        function updateLoveBrainMeter(index, level) {
            loveBrainIndicator.classList.remove('love-brain-hidden');
            
            // 更新数值
            meterValue.textContent = index;
            
            // 转换等级显示格式
            let displayLevel = level || '未知';
            if (level === '轻') displayLevel = '轻度';
            else if (level === '中') displayLevel = '中度';
            else if (level === '重') displayLevel = '重度';
            else if (level === '危险') displayLevel = '危险';
            
            meterLevel.textContent = displayLevel;
            
            // 更新进度条
            meterFill.style.width = `${index}%`;
            
            // 更新等级样式 - 使用原始的level作为CSS类名
            meterLevel.className = 'meter-level';
            if (level) {
                meterLevel.classList.add(level);
            }
            
            // 添加动画效果
            loveBrainIndicator.style.animation = 'pulse 0.5s ease-in-out';
            setTimeout(() => {
                loveBrainIndicator.style.animation = '';
            }, 500);
        }

        // 重置恋爱脑指数
        function resetLoveBrainMeter() {
            loveBrainIndicator.classList.add('love-brain-hidden');
            meterFill.style.width = '0%';
            meterLevel.textContent = '未检测';
            meterLevel.className = 'meter-level';
            meterValue.textContent = '--';
        }

        // 加载记忆状态
        async function loadMemoryStats() {
            try {
                const response = await fetch('/memory/stats');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                updateMemoryStats(data);
            } catch (error) {
                console.error('❌ 加载记忆状态失败:', error);
                // 设置默认值
                resetMemoryStats();
            }
        }

        // 更新记忆状态
        function updateMemoryStats(stats) {
            if (!stats) {
                console.warn('⚠️ 记忆状态数据为空');
                return;
            }
            
            // 更新轮数
            const roundCount = stats.conversation_count || 0;
            memoryRounds.textContent = roundCount;
            
            // 更新使用率
            const usageRatio = stats.memory_usage_ratio || 0;
            const usagePercent = Math.round(usageRatio * 100);
            memoryUsage.textContent = `${usagePercent}%`;
            
            // 更新样式
            memoryUsage.className = 'memory-usage';
            if (usagePercent >= 80) {
                memoryUsage.classList.add('high');
            } else if (usagePercent >= 60) {
                memoryUsage.classList.add('medium');
            } else {
                memoryUsage.classList.add('low');
            }
            
            // 更新提示信息
            let tooltipText = `对话轮数: ${stats.conversation_count}\n`;
            tooltipText += `Token使用: ${stats.estimated_tokens}/${stats.max_tokens}\n`;
            tooltipText += `使用率: ${usagePercent}%`;
            
            if (stats.user_patterns && Object.keys(stats.user_patterns).length > 0) {
                tooltipText += '\n行为模式: ' + Object.entries(stats.user_patterns)
                    .map(([pattern, count]) => `${pattern}(${count})`)
                    .join(', ');
            }
            
            memoryIndicator.title = tooltipText;
        }

        // 记忆详情点击事件
        function showMemoryModal(data) {
            // 移除已存在的modal
            const oldModal = document.getElementById('memoryModal');
            if (oldModal) oldModal.remove();

            const modal = document.createElement('div');
            modal.id = 'memoryModal';
            modal.style.position = 'fixed';
            modal.style.left = '0';
            modal.style.top = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.background = 'rgba(0,0,0,0.6)';
            modal.style.zIndex = '9999';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.backdropFilter = 'blur(4px)';

            const content = document.createElement('div');
            content.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            content.style.padding = '40px';
            content.style.borderRadius = '20px';
            content.style.maxWidth = '1200px';
            content.style.width = '95vw';
            content.style.maxHeight = '90vh';
            content.style.overflow = 'auto';
            content.style.position = 'relative';
            content.style.boxShadow = '0 20px 40px rgba(0,0,0,0.3)';
            content.style.border = '2px solid rgba(255,255,255,0.1)';
            content.style.color = 'white';
            content.style.fontFamily = 'Inter, sans-serif';

            // 关闭按钮
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '✕';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '16px';
            closeBtn.style.right = '20px';
            closeBtn.style.fontSize = '1.5rem';
            closeBtn.style.background = 'rgba(255,255,255,0.2)';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '50%';
            closeBtn.style.width = '36px';
            closeBtn.style.height = '36px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.color = 'white';
            closeBtn.style.display = 'flex';
            closeBtn.style.alignItems = 'center';
            closeBtn.style.justifyContent = 'center';
            closeBtn.style.transition = 'all 0.3s ease';
            closeBtn.onmouseover = () => {
                closeBtn.style.background = 'rgba(255,255,255,0.3)';
                closeBtn.style.transform = 'scale(1.1)';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = 'rgba(255,255,255,0.2)';
                closeBtn.style.transform = 'scale(1)';
            };
            closeBtn.onclick = () => modal.remove();
            content.appendChild(closeBtn);

            // 标题
            const title = document.createElement('h2');
            title.textContent = '🧠 智能记忆详情';
            title.style.marginTop = '0';
            title.style.marginBottom = '32px';
            title.style.fontSize = '2rem';
            title.style.fontWeight = '600';
            title.style.textAlign = 'center';
            title.style.textShadow = '0 2px 4px rgba(0,0,0,0.3)';
            content.appendChild(title);

            // 创建网格容器
            const gridContainer = document.createElement('div');
            gridContainer.style.display = 'grid';
            gridContainer.style.gridTemplateColumns = '1fr 1fr';
            gridContainer.style.gap = '24px';
            gridContainer.style.marginBottom = '20px';
            content.appendChild(gridContainer);

            // 统计信息卡片
            const stats = data.stats || {};
            const statsCard = document.createElement('div');
            statsCard.style.background = 'rgba(255,255,255,0.1)';
            statsCard.style.padding = '20px';
            statsCard.style.borderRadius = '12px';
            statsCard.style.backdropFilter = 'blur(10px)';
            statsCard.style.border = '1px solid rgba(255,255,255,0.2)';
            
            statsCard.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 16px;">
                    <span style="font-size: 1.5rem; margin-right: 8px;">📊</span>
                    <strong style="font-size: 1.1rem;">统计信息</strong>
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 0.9rem;">
                    <div>对话轮数: <span style="color: #ffd700; font-weight: 600;">${stats.conversation_count || 0}</span></div>
                    <div>Token使用: <span style="color: #ffd700; font-weight: 600;">${stats.estimated_tokens || 0}/${stats.max_tokens || 0}</span></div>
                    <div>使用率: <span style="color: #ffd700; font-weight: 600;">${Math.round((stats.memory_usage_ratio || 0) * 100)}%</span></div>
                    <div>行为模式: <span style="color: #ffd700; font-weight: 600;">${stats.pattern_count || 0}种</span></div>
                </div>
            `;
            gridContainer.appendChild(statsCard);

            // 用户画像卡片
            if (data.user_profile && data.user_profile.summary) {
                const profileCard = document.createElement('div');
                profileCard.style.background = 'rgba(255,255,255,0.1)';
                profileCard.style.padding = '20px';
                profileCard.style.borderRadius = '12px';
                profileCard.style.backdropFilter = 'blur(10px)';
                profileCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                let profileContent = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">👤</span>
                        <strong style="font-size: 1.1rem;">用户画像分析</strong>
                    </div>
                    <div style="font-size: 0.9rem; line-height: 1.6; margin-bottom: 12px;">
                        ${data.user_profile.summary}
                    </div>
                `;
                
                if (data.user_profile.personality_traits && data.user_profile.personality_traits.length > 0) {
                    profileContent += `
                        <div style="margin-top: 12px;">
                            <strong style="color: #ffd700;">个性特征:</strong>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                                ${data.user_profile.personality_traits.map(trait => 
                                    `<span style="background: rgba(255,215,0,0.2); padding: 6px 12px; border-radius: 16px; font-size: 0.85rem; border: 1px solid rgba(255,215,0,0.3);">${trait}</span>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                }
                
                profileCard.innerHTML = profileContent;
                gridContainer.appendChild(profileCard);
            } else {
                // 如果用户画像为空，创建一个占位卡片
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">👤</span>用户画像数据不足</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // 上下文摘要
            if (data.context_summary && data.context_summary !== "暂无记忆上下文") {
                const ctxCard = document.createElement('div');
                ctxCard.style.background = 'rgba(255,255,255,0.1)';
                ctxCard.style.padding = '20px';
                ctxCard.style.borderRadius = '12px';
                ctxCard.style.backdropFilter = 'blur(10px)';
                ctxCard.style.border = '1px solid rgba(255,255,255,0.2)';
                ctxCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">📋</span>
                        <strong style="font-size: 1.1rem;">上下文摘要</strong>
                    </div>
                    <div style="font-size: 0.9rem; line-height: 1.6;">${data.context_summary}</div>
                `;
                gridContainer.appendChild(ctxCard);
            } else {
                // 如果上下文摘要为空，创建一个占位卡片
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">📋</span>暂无上下文摘要</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // 行为模式分析
            if (stats.user_patterns && Object.keys(stats.user_patterns).length > 0) {
                const patternCard = document.createElement('div');
                patternCard.style.background = 'rgba(255,255,255,0.1)';
                patternCard.style.padding = '20px';
                patternCard.style.borderRadius = '12px';
                patternCard.style.backdropFilter = 'blur(10px)';
                patternCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                const patternItems = Object.entries(stats.user_patterns)
                    .sort((a, b) => b[1] - a[1])
                    .map(([pattern, count]) => {
                        const intensity = count >= 3 ? '🔴' : count >= 2 ? '🟡' : '🟢';
                        return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <span style="font-size: 0.95rem;">${intensity} ${pattern}</span>
                            <span style="color: #ffd700; font-weight: 600; font-size: 0.95rem;">${count}次</span>
                        </div>`;
                    }).join('');
                
                patternCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">🎯</span>
                        <strong style="font-size: 1.1rem;">行为模式分析</strong>
                    </div>
                    <div style="font-size: 0.9rem;">
                        ${patternItems}
                    </div>
                `;
                gridContainer.appendChild(patternCard);
            } else {
                // 如果行为模式为空，创建一个占位卡片
                const placeholderCard = document.createElement('div');
                placeholderCard.style.background = 'rgba(255,255,255,0.05)';
                placeholderCard.style.padding = '20px';
                placeholderCard.style.borderRadius = '12px';
                placeholderCard.style.border = '1px dashed rgba(255,255,255,0.2)';
                placeholderCard.style.display = 'flex';
                placeholderCard.style.alignItems = 'center';
                placeholderCard.style.justifyContent = 'center';
                placeholderCard.style.color = 'rgba(255,255,255,0.6)';
                placeholderCard.innerHTML = '<div style="text-align: center;"><span style="font-size: 2rem; margin-bottom: 8px; display: block;">🎯</span>暂无行为模式数据</div>';
                gridContainer.appendChild(placeholderCard);
            }

            // 关键洞察
            if (data.long_term_details && data.long_term_details.key_insights && data.long_term_details.key_insights.length > 0) {
                const insightCard = document.createElement('div');
                insightCard.style.background = 'rgba(255,255,255,0.1)';
                insightCard.style.padding = '20px';
                insightCard.style.borderRadius = '12px';
                insightCard.style.backdropFilter = 'blur(10px)';
                insightCard.style.border = '1px solid rgba(255,255,255,0.2)';
                
                const insightItems = data.long_term_details.key_insights
                    .slice(-3) // 只显示最近3条
                    .map(insight => `<div style="padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 0.9rem; line-height: 1.5;">💡 ${insight}</div>`)
                    .join('');
                
                insightCard.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <span style="font-size: 1.5rem; margin-right: 8px;">💡</span>
                        <strong style="font-size: 1.1rem;">关键洞察</strong>
                    </div>
                    <div>
                        ${insightItems}
                    </div>
                `;
                gridContainer.appendChild(insightCard);
            }

            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // 添加动画效果
            content.style.opacity = '0';
            content.style.transform = 'scale(0.8)';
            setTimeout(() => {
                content.style.transition = 'all 0.3s ease';
                content.style.opacity = '1';
                content.style.transform = 'scale(1)';
            }, 10);
        }

        memoryIndicator.addEventListener('click', async function() {
            try {
                const response = await fetch('/memory/summary');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                showMemoryModal(data);
            } catch (error) {
                console.error('获取记忆详情失败:', error);
                alert('获取记忆详情失败，请稍后重试');
            }
        });

        // 重置记忆状态
        function resetMemoryStats() {
            memoryRounds.textContent = '0';
            memoryUsage.textContent = '0%';
            memoryUsage.className = 'memory-usage low';
            memoryIndicator.title = '记忆已重置';
        }
    </script>
</body>
</html>
